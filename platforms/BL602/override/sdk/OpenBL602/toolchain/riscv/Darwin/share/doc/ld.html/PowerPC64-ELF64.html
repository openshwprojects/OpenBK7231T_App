<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This file documents the GNU linker LD
(SiFive Binutils-Metal 2.35.0-2020.12.8)
version 2.35.

Copyright (C) 1991-2020 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3
or any later version published by the Free Software Foundation;
with no Invariant Sections, with no Front-Cover Texts, and with no
Back-Cover Texts.  A copy of the license is included in the
section entitled "GNU Free Documentation License". -->
<!-- Created by GNU Texinfo 6.7, http://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>PowerPC64 ELF64 (LD)</title>

<meta name="description" content="PowerPC64 ELF64 (LD)">
<meta name="keywords" content="PowerPC64 ELF64 (LD)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html" rel="start" title="Top">
<link href="LD-Index.html" rel="index" title="LD Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Machine-Dependent.html" rel="up" title="Machine Dependent">
<link href="S_002f390-ELF.html" rel="next" title="S/390 ELF">
<link href="PowerPC-ELF32.html" rel="prev" title="PowerPC ELF32">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<span id="PowerPC64-ELF64"></span><div class="header">
<p>
Next: <a href="S_002f390-ELF.html" accesskey="n" rel="next">S/390 ELF</a>, Previous: <a href="PowerPC-ELF32.html" accesskey="p" rel="prev">PowerPC ELF32</a>, Up: <a href="Machine-Dependent.html" accesskey="u" rel="up">Machine Dependent</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="LD-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="ld-and-PowerPC64-64_002dbit-ELF-Support"></span><h3 class="section">4.12 <code>ld</code> and PowerPC64 64-bit ELF Support</h3>

<span id="index-PowerPC64-ELF64-options"></span>
<dl compact="compact">
<dd><span id="index-PowerPC64-stub-grouping"></span>
<span id="index-_002d_002dstub_002dgroup_002dsize"></span>
</dd>
<dt><samp>--stub-group-size</samp></dt>
<dd><p>Long branch stubs, PLT call stubs  and TOC adjusting stubs are placed
by <code>ld</code> in stub sections located between groups of input sections.
&lsquo;<samp>--stub-group-size</samp>&rsquo; specifies the maximum size of a group of input
sections handled by one stub section.  Since branch offsets are signed,
a stub section may serve two groups of input sections, one group before
the stub section, and one group after it.  However, when using
conditional branches that require stubs, it may be better (for branch
prediction) that stub sections only serve one group of input sections.
A negative value for &lsquo;<samp>N</samp>&rsquo; chooses this scheme, ensuring that
branches to stubs always use a negative offset.  Two special values of
&lsquo;<samp>N</samp>&rsquo; are recognized, &lsquo;<samp>1</samp>&rsquo; and &lsquo;<samp>-1</samp>&rsquo;.  These both instruct
<code>ld</code> to automatically size input section groups for the branch types
detected, with the same behaviour regarding stub placement as other
positive or negative values of &lsquo;<samp>N</samp>&rsquo; respectively.
</p>
<p>Note that &lsquo;<samp>--stub-group-size</samp>&rsquo; does not split input sections.  A
single input section larger than the group size specified will of course
create a larger group (of one section).  If input sections are too
large, it may not be possible for a branch to reach its stub.
</p>
<span id="index-PowerPC64-stub-symbols"></span>
<span id="index-_002d_002demit_002dstub_002dsyms-1"></span>
</dd>
<dt><samp>--emit-stub-syms</samp></dt>
<dd><p>This option causes <code>ld</code> to label linker stubs with a local
symbol that encodes the stub type and destination.
</p>
<span id="index-PowerPC64-dot-symbols"></span>
<span id="index-_002d_002ddotsyms"></span>
<span id="index-_002d_002dno_002ddotsyms"></span>
</dd>
<dt><samp>--dotsyms</samp></dt>
<dt><samp>--no-dotsyms</samp></dt>
<dd><p>These two options control how <code>ld</code> interprets version patterns
in a version script.  Older PowerPC64 compilers emitted both a
function descriptor symbol with the same name as the function, and a
code entry symbol with the name prefixed by a dot (&lsquo;<samp>.</samp>&rsquo;).  To
properly version a function &lsquo;<samp>foo</samp>&rsquo;, the version script thus needs
to control both &lsquo;<samp>foo</samp>&rsquo; and &lsquo;<samp>.foo</samp>&rsquo;.  The option
&lsquo;<samp>--dotsyms</samp>&rsquo;, on by default, automatically adds the required
dot-prefixed patterns.  Use &lsquo;<samp>--no-dotsyms</samp>&rsquo; to disable this
feature.
</p>
<span id="index-PowerPC64-register-save_002frestore-functions"></span>
<span id="index-_002d_002dsave_002drestore_002dfuncs"></span>
<span id="index-_002d_002dno_002dsave_002drestore_002dfuncs"></span>
</dd>
<dt><samp>--save-restore-funcs</samp></dt>
<dt><samp>--no-save-restore-funcs</samp></dt>
<dd><p>These two options control whether PowerPC64 <code>ld</code> automatically
provides out-of-line register save and restore functions used by
&lsquo;<samp>-Os</samp>&rsquo; code.  The default is to provide any such referenced
function for a normal final link, and to not do so for a relocatable
link.
</p>
<span id="index-PowerPC64-TLS-optimization"></span>
<span id="index-_002d_002dno_002dtls_002doptimize-1"></span>
</dd>
<dt><samp>--no-tls-optimize</samp></dt>
<dd><p>PowerPC64 <code>ld</code> normally performs some optimization of code
sequences used to access Thread-Local Storage.  Use this option to
disable the optimization.
</p>
<span id="index-PowerPC64-_005f_005ftls_005fget_005faddr-optimization"></span>
<span id="index-_002d_002dtls_002dget_002daddr_002doptimize"></span>
<span id="index-_002d_002dno_002dtls_002dget_002daddr_002doptimize"></span>
<span id="index-_002d_002dtls_002dget_002daddr_002dregsave"></span>
<span id="index-_002d_002dno_002dtls_002dget_002daddr_002dregsave"></span>
</dd>
<dt><samp>--tls-get-addr-optimize</samp></dt>
<dt><samp>--no-tls-get-addr-optimize</samp></dt>
<dd><p>These options control how PowerPC64 <code>ld</code> uses a special
stub to call __tls_get_addr.  PowerPC64 glibc 2.22 and later support
an optimization that allows the second and subsequent calls to
<code>__tls_get_addr</code> for a given symbol to be resolved by the special
stub without calling in to glibc.  By default the linker enables
generation of the stub when glibc advertises the availability of
__tls_get_addr_opt.
Using <samp>--tls-get-addr-optimize</samp> with an older glibc won&rsquo;t do
much besides slow down your applications, but may be useful if linking
an application against an older glibc with the expectation that it
will normally be used on systems having a newer glibc.
<samp>--tls-get-addr-regsave</samp> forces generation of a stub that saves
and restores volatile registers around the call into glibc.  Normally,
this is done when the linker detects a call to __tls_get_addr_desc.
Such calls then go via the register saving stub to __tls_get_addr_opt.
<samp>--no-tls-get-addr-regsave</samp> disables generation of the
register saves.
</p>
<span id="index-PowerPC64-OPD-optimization"></span>
<span id="index-_002d_002dno_002dopd_002doptimize"></span>
</dd>
<dt><samp>--no-opd-optimize</samp></dt>
<dd><p>PowerPC64 <code>ld</code> normally removes <code>.opd</code> section entries
corresponding to deleted link-once functions, or functions removed by
the action of &lsquo;<samp>--gc-sections</samp>&rsquo; or linker script <code>/DISCARD/</code>.
Use this option to disable <code>.opd</code> optimization.
</p>
<span id="index-PowerPC64-OPD-spacing"></span>
<span id="index-_002d_002dnon_002doverlapping_002dopd"></span>
</dd>
<dt><samp>--non-overlapping-opd</samp></dt>
<dd><p>Some PowerPC64 compilers have an option to generate compressed
<code>.opd</code> entries spaced 16 bytes apart, overlapping the third word,
the static chain pointer (unused in C) with the first word of the next
entry.  This option expands such entries to the full 24 bytes.
</p>
<span id="index-PowerPC64-TOC-optimization"></span>
<span id="index-_002d_002dno_002dtoc_002doptimize"></span>
</dd>
<dt><samp>--no-toc-optimize</samp></dt>
<dd><p>PowerPC64 <code>ld</code> normally removes unused <code>.toc</code> section
entries.  Such entries are detected by examining relocations that
reference the TOC in code sections.  A reloc in a deleted code section
marks a TOC word as unneeded, while a reloc in a kept code section
marks a TOC word as needed.  Since the TOC may reference itself, TOC
relocs are also examined.  TOC words marked as both needed and
unneeded will of course be kept.  TOC words without any referencing
reloc are assumed to be part of a multi-word entry, and are kept or
discarded as per the nearest marked preceding word.  This works
reliably for compiler generated code, but may be incorrect if assembly
code is used to insert TOC entries.  Use this option to disable the
optimization.
</p>
<span id="index-PowerPC64-inline-PLT-call-optimization"></span>
<span id="index-_002d_002dno_002dinline_002doptimize"></span>
</dd>
<dt><samp>--no-inline-optimize</samp></dt>
<dd><p>PowerPC64 <code>ld</code> normally replaces inline PLT call sequences
marked with <code>R_PPC64_PLTSEQ</code>, <code>R_PPC64_PLTCALL</code>,
<code>R_PPC64_PLT16_HA</code> and <code>R_PPC64_PLT16_LO_DS</code> relocations by
a number of <code>nop</code>s and a direct call when the function is defined
locally and can&rsquo;t be overridden by some other definition.  This option
disables that optimization.
</p>
<span id="index-PowerPC64-multi_002dTOC"></span>
<span id="index-_002d_002dno_002dmulti_002dtoc"></span>
</dd>
<dt><samp>--no-multi-toc</samp></dt>
<dd><p>If given any toc option besides <code>-mcmodel=medium</code> or
<code>-mcmodel=large</code>, PowerPC64 GCC generates code for a TOC model
where TOC
entries are accessed with a 16-bit offset from r2.  This limits the
total TOC size to 64K.  PowerPC64 <code>ld</code> extends this limit by
grouping code sections such that each group uses less than 64K for its
TOC entries, then inserts r2 adjusting stubs between inter-group
calls.  <code>ld</code> does not split apart input sections, so cannot
help if a single input file has a <code>.toc</code> section that exceeds
64K, most likely from linking multiple files with <code>ld -r</code>.
Use this option to turn off this feature.
</p>
<span id="index-PowerPC64-TOC-sorting"></span>
<span id="index-_002d_002dno_002dtoc_002dsort"></span>
</dd>
<dt><samp>--no-toc-sort</samp></dt>
<dd><p>By default, <code>ld</code> sorts TOC sections so that those whose file
happens to have a section called <code>.init</code> or <code>.fini</code> are
placed first, followed by TOC sections referenced by code generated
with PowerPC64 gcc&rsquo;s <code>-mcmodel=small</code>, and lastly TOC sections
referenced only by code generated with PowerPC64 gcc&rsquo;s
<code>-mcmodel=medium</code> or <code>-mcmodel=large</code> options.  Doing this
results in better TOC grouping for multi-TOC.  Use this option to turn
off this feature.
</p>
<span id="index-PowerPC64-PLT-stub-alignment"></span>
<span id="index-_002d_002dplt_002dalign"></span>
<span id="index-_002d_002dno_002dplt_002dalign"></span>
</dd>
<dt><samp>--plt-align</samp></dt>
<dt><samp>--no-plt-align</samp></dt>
<dd><p>Use these options to control whether individual PLT call stubs are
aligned to a 32-byte boundary, or to the specified power of two
boundary when using <code>--plt-align=</code>.  A negative value may be
specified to pad PLT call stubs so that they do not cross the
specified power of two boundary (or the minimum number of boundaries
if a PLT stub is so large that it must cross a boundary).  By default
PLT call stubs are aligned to 32-byte boundaries.
</p>
<span id="index-PowerPC64-PLT-call-stub-static-chain"></span>
<span id="index-_002d_002dplt_002dstatic_002dchain"></span>
<span id="index-_002d_002dno_002dplt_002dstatic_002dchain"></span>
</dd>
<dt><samp>--plt-static-chain</samp></dt>
<dt><samp>--no-plt-static-chain</samp></dt>
<dd><p>Use these options to control whether PLT call stubs load the static
chain pointer (r11).  <code>ld</code> defaults to not loading the static
chain since there is never any need to do so on a PLT call.
</p>
<span id="index-PowerPC64-PLT-call-stub-thread-safety"></span>
<span id="index-_002d_002dplt_002dthread_002dsafe"></span>
<span id="index-_002d_002dno_002dplt_002dthread_002dsafe"></span>
</dd>
<dt><samp>--plt-thread-safe</samp></dt>
<dt><samp>--no-plt-thread-safe</samp></dt>
<dd><p>With power7&rsquo;s weakly ordered memory model, it is possible when using
lazy binding for ld.so to update a plt entry in one thread and have
another thread see the individual plt entry words update in the wrong
order, despite ld.so carefully writing in the correct order and using
memory write barriers.  To avoid this we need some sort of read
barrier in the call stub, or use LD_BIND_NOW=1.  By default, <code>ld</code>
looks for calls to commonly used functions that create threads, and if
seen, adds the necessary barriers.  Use these options to change the
default behaviour.
</p>
<span id="index-PowerPC64-ELFv2-PLT-localentry-optimization"></span>
<span id="index-_002d_002dplt_002dlocalentry"></span>
<span id="index-_002d_002dno_002dplt_002dlocalentry"></span>
</dd>
<dt><samp>--plt-localentry</samp></dt>
<dt><samp>--no-localentry</samp></dt>
<dd><p>ELFv2 functions with localentry:0 are those with a single entry point,
ie. global entry == local entry, and that have no requirement on r2
(the TOC/GOT pointer) or r12, and guarantee r2 is unchanged on return.
Such an external function can be called via the PLT without saving r2
or restoring it on return, avoiding a common load-hit-store for small
functions.   The optimization is attractive, with up to 40% reduction
in execution time for a small function, but can result in symbol
interposition failures.  Also, minor changes in a shared library,
including system libraries, can cause a function that was localentry:0
to become localentry:8.  This will result in a dynamic loader
complaint and failure to run.  The option is experimental, use with
care.  <samp>--no-plt-localentry</samp> is the default.
</p>
<span id="index-PowerPC64-Power10-stubs"></span>
<span id="index-_002d_002dpower10_002dstubs"></span>
<span id="index-_002d_002dno_002dpower10_002dstubs"></span>
</dd>
<dt><samp>--power10-stubs</samp></dt>
<dt><samp>--no-power10-stubs</samp></dt>
<dd><p>When PowerPC64 <code>ld</code> links input object files containing
relocations used on power10 prefixed instructions it normally creates
linkage stubs (PLT call and long branch) using power10 instructions
for <code>@notoc</code> PLT calls where <code>r2</code> is not known.  The
power10 notoc stubs are smaller and faster, so are preferred for
power10.  <samp>--power10-stubs</samp> and <samp>--no-power10-stubs</samp>
allow you to override the linker&rsquo;s selection of stub instructions.
<samp>--power10-stubs=auto</samp> allows the user to select the default
auto mode.
</p></dd>
</dl>



<hr>
<div class="header">
<p>
Next: <a href="S_002f390-ELF.html" accesskey="n" rel="next">S/390 ELF</a>, Previous: <a href="PowerPC-ELF32.html" accesskey="p" rel="prev">PowerPC ELF32</a>, Up: <a href="Machine-Dependent.html" accesskey="u" rel="up">Machine Dependent</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="LD-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
