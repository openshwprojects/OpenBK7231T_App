<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This manual describes how to install and use the GNU multiple precision
arithmetic library, version 6.1.0.

Copyright 1991, 1993-2015 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.3 or any later
version published by the Free Software Foundation; with no Invariant Sections,
with the Front-Cover Texts being "A GNU Manual", and with the Back-Cover
Texts being "You have freedom to copy and modify this GNU Manual, like GNU
software".  A copy of the license is included in
GNU Free Documentation License. -->
<!-- Created by GNU Texinfo 6.7, http://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Number Theoretic Functions (GNU MP 6.1.0)</title>

<meta name="description" content="How to install and use the GNU multiple precision arithmetic library, version 6.1.0.">
<meta name="keywords" content="Number Theoretic Functions (GNU MP 6.1.0)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html" rel="start" title="Top">
<link href="Concept-Index.html" rel="index" title="Concept Index">
<link href="Integer-Functions.html" rel="up" title="Integer Functions">
<link href="Integer-Comparisons.html" rel="next" title="Integer Comparisons">
<link href="Integer-Roots.html" rel="prev" title="Integer Roots">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<span id="Number-Theoretic-Functions"></span><div class="header">
<p>
Next: <a href="Integer-Comparisons.html" accesskey="n" rel="next">Integer Comparisons</a>, Previous: <a href="Integer-Roots.html" accesskey="p" rel="prev">Integer Roots</a>, Up: <a href="Integer-Functions.html" accesskey="u" rel="up">Integer Functions</a> &nbsp; [<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="Number-Theoretic-Functions-1"></span><h3 class="section">5.9 Number Theoretic Functions</h3>
<span id="index-Number-theoretic-functions"></span>

<dl>
<dt id="index-mpz_005fprobab_005fprime_005fp">Function: <em>int</em> <strong>mpz_probab_prime_p</strong> <em>(const mpz_t <var>n</var>, int <var>reps</var>)</em></dt>
<dd><span id="index-Prime-testing-functions"></span>
<span id="index-Probable-prime-testing-functions"></span>
<p>Determine whether <var>n</var> is prime.  Return 2 if <var>n</var> is definitely prime,
return 1 if <var>n</var> is probably prime (without being certain), or return 0 if
<var>n</var> is definitely non-prime.
</p>
<p>This function performs some trial divisions, then <var>reps</var> Miller-Rabin
probabilistic primality tests.  A higher <var>reps</var> value will reduce the
chances of a non-prime being identified as &ldquo;probably prime&rdquo;.  A composite
number will be identified as a prime with a probability of less than
<em>4^(-<var>reps</var>)</em>.  Reasonable values of <var>reps</var> are between 15
and 50.
</p></dd></dl>

<dl>
<dt id="index-mpz_005fnextprime">Function: <em>void</em> <strong>mpz_nextprime</strong> <em>(mpz_t <var>rop</var>, const mpz_t <var>op</var>)</em></dt>
<dd><span id="index-Next-prime-function"></span>
<p>Set <var>rop</var> to the next prime greater than <var>op</var>.
</p>
<p>This function uses a probabilistic algorithm to identify primes.  For
practical purposes it&rsquo;s adequate, the chance of a composite passing will be
extremely small.
</p></dd></dl>




<dl>
<dt id="index-mpz_005fgcd">Function: <em>void</em> <strong>mpz_gcd</strong> <em>(mpz_t <var>rop</var>, const mpz_t <var>op1</var>, const mpz_t <var>op2</var>)</em></dt>
<dd><span id="index-Greatest-common-divisor-functions"></span>
<span id="index-GCD-functions"></span>
<p>Set <var>rop</var> to the greatest common divisor of <var>op1</var> and <var>op2</var>.  The
result is always positive even if one or both input operands are negative.
Except if both inputs are zero; then this function defines <em>gcd(0,0) = 0</em>.
</p></dd></dl>

<dl>
<dt id="index-mpz_005fgcd_005fui">Function: <em>unsigned long int</em> <strong>mpz_gcd_ui</strong> <em>(mpz_t <var>rop</var>, const mpz_t <var>op1</var>, unsigned long int <var>op2</var>)</em></dt>
<dd><p>Compute the greatest common divisor of <var>op1</var> and <var>op2</var>.  If
<var>rop</var> is not <code>NULL</code>, store the result there.
</p>
<p>If the result is small enough to fit in an <code>unsigned long int</code>, it is
returned.  If the result does not fit, 0 is returned, and the result is equal
to the argument <var>op1</var>.  Note that the result will always fit if <var>op2</var>
is non-zero.
</p></dd></dl>

<dl>
<dt id="index-mpz_005fgcdext">Function: <em>void</em> <strong>mpz_gcdext</strong> <em>(mpz_t <var>g</var>, mpz_t <var>s</var>, mpz_t <var>t</var>, const mpz_t <var>a</var>, const mpz_t <var>b</var>)</em></dt>
<dd><span id="index-Extended-GCD"></span>
<span id="index-GCD-extended"></span>
<p>Set <var>g</var> to the greatest common divisor of <var>a</var> and <var>b</var>, and in
addition set <var>s</var> and <var>t</var> to coefficients satisfying
<em><var>a</var>*<var>s</var> + <var>b</var>*<var>t</var> = <var>g</var></em>.
The value in <var>g</var> is always positive, even if one or both of <var>a</var> and
<var>b</var> are negative (or zero if both inputs are zero).  The values in <var>s</var>
and <var>t</var> are chosen such that normally, <em>abs(<var>s</var>) &lt;
abs(<var>b</var>) / (2 <var>g</var>)</em> and <em>abs(<var>t</var>) &lt; abs(<var>a</var>)
/ (2 <var>g</var>)</em>, and these relations define <var>s</var> and <var>t</var> uniquely.  There
are a few exceptional cases:
</p>
<p>If <em>abs(<var>a</var>) = abs(<var>b</var>)</em>, then <em><var>s</var> = 0</em>,
<em><var>t</var> = sgn(<var>b</var>)</em>.
</p>
<p>Otherwise, <em><var>s</var> = sgn(<var>a</var>)</em> if <em><var>b</var> = 0</em> or
<em>abs(<var>b</var>) = 2 <var>g</var></em>, and <em><var>t</var> = sgn(<var>b</var>)</em> if
<em><var>a</var> = 0</em> or <em>abs(<var>a</var>) = 2 <var>g</var></em>.
</p>
<p>In all cases, <em><var>s</var> = 0</em> if and only if <em><var>g</var> =
abs(<var>b</var>)</em>, i.e., if <var>b</var> divides <var>a</var> or <em><var>a</var> = <var>b</var>
= 0</em>.
</p>
<p>If <var>t</var> is <code>NULL</code> then that value is not computed.
</p></dd></dl>

<dl>
<dt id="index-mpz_005flcm">Function: <em>void</em> <strong>mpz_lcm</strong> <em>(mpz_t <var>rop</var>, const mpz_t <var>op1</var>, const mpz_t <var>op2</var>)</em></dt>
<dt id="index-mpz_005flcm_005fui">Function: <em>void</em> <strong>mpz_lcm_ui</strong> <em>(mpz_t <var>rop</var>, const mpz_t <var>op1</var>, unsigned long <var>op2</var>)</em></dt>
<dd><span id="index-Least-common-multiple-functions"></span>
<span id="index-LCM-functions"></span>
<p>Set <var>rop</var> to the least common multiple of <var>op1</var> and <var>op2</var>.
<var>rop</var> is always positive, irrespective of the signs of <var>op1</var> and
<var>op2</var>.  <var>rop</var> will be zero if either <var>op1</var> or <var>op2</var> is zero.
</p></dd></dl>

<dl>
<dt id="index-mpz_005finvert">Function: <em>int</em> <strong>mpz_invert</strong> <em>(mpz_t <var>rop</var>, const mpz_t <var>op1</var>, const mpz_t <var>op2</var>)</em></dt>
<dd><span id="index-Modular-inverse-functions"></span>
<span id="index-Inverse-modulo-functions"></span>
<p>Compute the inverse of <var>op1</var> modulo <var>op2</var> and put the result in
<var>rop</var>.  If the inverse exists, the return value is non-zero and <var>rop</var>
will satisfy <em>0 &lt;= <var>rop</var> &lt; abs(<var>op2</var>)</em> (with <em><var>rop</var>
= 0</em> possible only when <em>abs(<var>op2</var>) = 1</em>, i.e., in the
somewhat degenerate zero ring).  If an inverse doesn&rsquo;t
exist the return value is zero and <var>rop</var> is undefined.  The behaviour of
this function is undefined when <var>op2</var> is zero.
</p></dd></dl>

<dl>
<dt id="index-mpz_005fjacobi">Function: <em>int</em> <strong>mpz_jacobi</strong> <em>(const mpz_t <var>a</var>, const mpz_t <var>b</var>)</em></dt>
<dd><span id="index-Jacobi-symbol-functions"></span>
<p>Calculate the Jacobi symbol <em>(<var>a</var>/<var>b</var>)</em>.  This is defined only for <var>b</var> odd.
</p></dd></dl>

<dl>
<dt id="index-mpz_005flegendre">Function: <em>int</em> <strong>mpz_legendre</strong> <em>(const mpz_t <var>a</var>, const mpz_t <var>p</var>)</em></dt>
<dd><span id="index-Legendre-symbol-functions"></span>
<p>Calculate the Legendre symbol <em>(<var>a</var>/<var>p</var>)</em>.  This is defined only for <var>p</var> an odd positive
prime, and for such <var>p</var> it&rsquo;s identical to the Jacobi symbol.
</p></dd></dl>

<dl>
<dt id="index-mpz_005fkronecker">Function: <em>int</em> <strong>mpz_kronecker</strong> <em>(const mpz_t <var>a</var>, const mpz_t <var>b</var>)</em></dt>
<dt id="index-mpz_005fkronecker_005fsi">Function: <em>int</em> <strong>mpz_kronecker_si</strong> <em>(const mpz_t <var>a</var>, long <var>b</var>)</em></dt>
<dt id="index-mpz_005fkronecker_005fui">Function: <em>int</em> <strong>mpz_kronecker_ui</strong> <em>(const mpz_t <var>a</var>, unsigned long <var>b</var>)</em></dt>
<dt id="index-mpz_005fsi_005fkronecker">Function: <em>int</em> <strong>mpz_si_kronecker</strong> <em>(long <var>a</var>, const mpz_t <var>b</var>)</em></dt>
<dt id="index-mpz_005fui_005fkronecker">Function: <em>int</em> <strong>mpz_ui_kronecker</strong> <em>(unsigned long <var>a</var>, const mpz_t <var>b</var>)</em></dt>
<dd><span id="index-Kronecker-symbol-functions"></span>
<p>Calculate the Jacobi symbol <em>(<var>a</var>/<var>b</var>)</em> with the Kronecker extension <em>(a/2)=(2/a)</em> when <em>a</em> odd, or
<em>(a/2)=0</em> when <em>a</em> even.
</p>
<p>When <var>b</var> is odd the Jacobi symbol and Kronecker symbol are
identical, so <code>mpz_kronecker_ui</code> etc can be used for mixed
precision Jacobi symbols too.
</p>
<p>For more information see Henri Cohen section 1.4.2 (see <a href="References.html">References</a>),
or any number theory textbook.  See also the example program
<samp>demos/qcn.c</samp> which uses <code>mpz_kronecker_ui</code>.
</p></dd></dl>

<dl>
<dt id="index-mpz_005fremove">Function: <em>mp_bitcnt_t</em> <strong>mpz_remove</strong> <em>(mpz_t <var>rop</var>, const mpz_t <var>op</var>, const mpz_t <var>f</var>)</em></dt>
<dd><span id="index-Remove-factor-functions"></span>
<span id="index-Factor-removal-functions"></span>
<p>Remove all occurrences of the factor <var>f</var> from <var>op</var> and store the
result in <var>rop</var>.  The return value is how many such occurrences were
removed.
</p></dd></dl>

<dl>
<dt id="index-mpz_005ffac_005fui">Function: <em>void</em> <strong>mpz_fac_ui</strong> <em>(mpz_t <var>rop</var>, unsigned long int <var>n</var>)</em></dt>
<dt id="index-mpz_005f2fac_005fui">Function: <em>void</em> <strong>mpz_2fac_ui</strong> <em>(mpz_t <var>rop</var>, unsigned long int <var>n</var>)</em></dt>
<dt id="index-mpz_005fmfac_005fuiui">Function: <em>void</em> <strong>mpz_mfac_uiui</strong> <em>(mpz_t <var>rop</var>, unsigned long int <var>n</var>, unsigned long int <var>m</var>)</em></dt>
<dd><span id="index-Factorial-functions"></span>
<p>Set <var>rop</var> to the factorial of <var>n</var>: <code>mpz_fac_ui</code> computes the plain factorial <var>n</var>!,
<code>mpz_2fac_ui</code> computes the double-factorial <var>n</var>!!, and <code>mpz_mfac_uiui</code> the
<var>m</var>-multi-factorial <em><var>n</var>!^(<var>m</var>)</em>.
</p></dd></dl>

<dl>
<dt id="index-mpz_005fprimorial_005fui">Function: <em>void</em> <strong>mpz_primorial_ui</strong> <em>(mpz_t <var>rop</var>, unsigned long int <var>n</var>)</em></dt>
<dd><span id="index-Primorial-functions"></span>
<p>Set <var>rop</var> to the primorial of <var>n</var>, i.e. the product of all positive
prime numbers <em>&lt;=<var>n</var></em>.
</p></dd></dl>

<dl>
<dt id="index-mpz_005fbin_005fui">Function: <em>void</em> <strong>mpz_bin_ui</strong> <em>(mpz_t <var>rop</var>, const mpz_t <var>n</var>, unsigned long int <var>k</var>)</em></dt>
<dt id="index-mpz_005fbin_005fuiui">Function: <em>void</em> <strong>mpz_bin_uiui</strong> <em>(mpz_t <var>rop</var>, unsigned long int <var>n</var>, unsigned&nbsp;long&nbsp;int&nbsp;<var>k</var><!-- /@w -->)</em></dt>
<dd><span id="index-Binomial-coefficient-functions"></span>
<p>Compute the binomial coefficient <em><var>n</var> over
<var>k</var></em> and store the result in <var>rop</var>.  Negative values of <var>n</var> are
supported by <code>mpz_bin_ui</code>, using the identity
<em>bin(-n,k) = (-1)^k * bin(n+k-1,k)</em>, see Knuth volume 1 section 1.2.6
part G.
</p></dd></dl>

<dl>
<dt id="index-mpz_005ffib_005fui">Function: <em>void</em> <strong>mpz_fib_ui</strong> <em>(mpz_t <var>fn</var>, unsigned long int <var>n</var>)</em></dt>
<dt id="index-mpz_005ffib2_005fui">Function: <em>void</em> <strong>mpz_fib2_ui</strong> <em>(mpz_t <var>fn</var>, mpz_t <var>fnsub1</var>, unsigned long int <var>n</var>)</em></dt>
<dd><span id="index-Fibonacci-sequence-functions"></span>
<p><code>mpz_fib_ui</code> sets <var>fn</var> to to <em>F[n]</em>, the <var>n</var>&rsquo;th Fibonacci
number.  <code>mpz_fib2_ui</code> sets <var>fn</var> to <em>F[n]</em>, and <var>fnsub1</var> to
<em>F[n-1]</em>.
</p>
<p>These functions are designed for calculating isolated Fibonacci numbers.  When
a sequence of values is wanted it&rsquo;s best to start with <code>mpz_fib2_ui</code> and
iterate the defining <em>F[n+1]=F[n]+F[n-1]</em> or
similar.
</p></dd></dl>

<dl>
<dt id="index-mpz_005flucnum_005fui">Function: <em>void</em> <strong>mpz_lucnum_ui</strong> <em>(mpz_t <var>ln</var>, unsigned long int <var>n</var>)</em></dt>
<dt id="index-mpz_005flucnum2_005fui">Function: <em>void</em> <strong>mpz_lucnum2_ui</strong> <em>(mpz_t <var>ln</var>, mpz_t <var>lnsub1</var>, unsigned long int <var>n</var>)</em></dt>
<dd><span id="index-Lucas-number-functions"></span>
<p><code>mpz_lucnum_ui</code> sets <var>ln</var> to to <em>L[n]</em>, the <var>n</var>&rsquo;th Lucas
number.  <code>mpz_lucnum2_ui</code> sets <var>ln</var> to <em>L[n]</em>, and <var>lnsub1</var>
to <em>L[n-1]</em>.
</p>
<p>These functions are designed for calculating isolated Lucas numbers.  When a
sequence of values is wanted it&rsquo;s best to start with <code>mpz_lucnum2_ui</code> and
iterate the defining <em>L[n+1]=L[n]+L[n-1]</em> or
similar.
</p>
<p>The Fibonacci numbers and Lucas numbers are related sequences, so it&rsquo;s never
necessary to call both <code>mpz_fib2_ui</code> and <code>mpz_lucnum2_ui</code>.  The
formulas for going from Fibonacci to Lucas can be found in <a href="Lucas-Numbers-Algorithm.html">Lucas Numbers Algorithm</a>, the reverse is straightforward too.
</p></dd></dl>


<hr>
<div class="header">
<p>
Next: <a href="Integer-Comparisons.html" accesskey="n" rel="next">Integer Comparisons</a>, Previous: <a href="Integer-Roots.html" accesskey="p" rel="prev">Integer Roots</a>, Up: <a href="Integer-Functions.html" accesskey="u" rel="up">Integer Functions</a> &nbsp; [<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
