diff --git a/src/driver/drv_roomba.c b/src/driver/drv_roomba.c
index 0000000..0000000 100644
--- a/src/driver/drv_roomba.c
+++ b/src/driver/drv_roomba.c
@@ -1,3 +1,9 @@
+// Last raw Group 6 frame (52 bytes) for debug/visibility (Phase 1)
+static byte g_last_group6_frame[52];
+static int  g_last_group6_valid = 0;
+
@@
 void Roomba_OnQuickTick() {
 int avail = UART_GetDataSizeEx(g_roomba_uart);
-
-// Parse Group 6 response (52 bytes) when available
-if (avail >= 52) {
-byte buf[52];
-for (int i = 0; i < 52; i++) {
-buf[i] = UART_GetByteEx(g_roomba_uart, i);
-}
-
-// Sanity Check: Charging State (Byte 16) must be 0-5
-if (buf[16] > 5) {
-addLogAdv(LOG_WARN, LOG_FEATURE_DRV, "Roomba: Invalid Charging State (%d). Flushing buffer.", buf[16]);
-UART_ConsumeBytesEx(g_roomba_uart, avail);
-return;
-}
+
+// Parse Group 6 response (52 bytes) when available
+// Phase 1 robustness: resync by consuming 1 byte at a time if frame alignment is wrong
+if (avail >= 52) {
+int guard = 0;
+while (avail >= 52 && guard++ < 256) {
+// Peek Charging State (Packet 21) at offset 16
+byte cs = UART_GetByteEx(g_roomba_uart, 16);
+if (cs > 5) {
+// Misaligned stream - slide by 1 byte, do NOT flush everything
+UART_ConsumeBytesEx(g_roomba_uart, 1);
+avail = UART_GetDataSizeEx(g_roomba_uart);
+continue;
+}
+
+byte buf[52];
+for (int i = 0; i < 52; i++) {
+buf[i] = UART_GetByteEx(g_roomba_uart, i);
+}
+
+// Save last raw frame for future UI display / debugging
+for (int i = 0; i < 52; i++) {
+g_last_group6_frame[i] = buf[i];
+}
+g_last_group6_valid = 1;
 
 // --- PARSE PACKET GROUP 6 (Packets 7-42) ---
 
 // Packet 7: Bumps & Wheel Drops (Byte 0)
@@
 // Publish sensors via MQTT (BL_shared style)
 Roomba_PublishSensors();
 
 // Consume the 52 bytes from buffer
 UART_ConsumeBytesEx(g_roomba_uart, 52);
+break;
+}
 }
 else if (avail > 64) {
 // Flush buffer if it's getting full (likely garbage)
 addLogAdv(LOG_WARN, LOG_FEATURE_DRV, "Roomba: Flushing overfull buffer (%d bytes)", avail);
 UART_ConsumeBytesEx(g_roomba_uart, avail);
 }
 }